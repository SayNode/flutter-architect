// This file has been automatically generated by Flutter Architect.
//
// Flutter Architect is a tool that generates boilerplate code for your Flutter projects.
// Flutter Architect was created at SayNode Operations AG by Yann Marti, Francesco Romeo and Pedro Gon√ßalves.
//
// https://saynode.ch
import 'package:sign_in_with_apple/sign_in_with_apple.dart';
import 'package:flutter/services.dart';
import 'package:flutter/foundation.dart';
import 'package:google_sign_in/google_sign_in.dart';
import '../model/auth_response.dart';
import 'package:http/http.dart' as http;
import 'dart:convert';

import '../base/auth_service_base.dart';

class AuthService extends AuthServiceBase {
  // Add your custom code here
  // Login with Apple.
  Future<AuthResponse> appleSignIn({
    String? authorizationCode,
    String? identityToken,
  }) async {
    try {
      if (authorizationCode != null &&
          identityToken != null &&
          authorizationCode.isNotEmpty &&
          identityToken.isNotEmpty) {
        final AuthorizationCredentialAppleID credential =
            await SignInWithApple.getAppleIDCredential(
          scopes: <AppleIDAuthorizationScopes>[
            AppleIDAuthorizationScopes.email,
            AppleIDAuthorizationScopes.fullName,
          ],
          webAuthenticationOptions: WebAuthenticationOptions(
            clientId: '', // TODO
            redirectUri:
                // For web your redirect URI needs to be the host of the "current page",
                // while for Android you will be using the API server that redirects back into your app via a deep link
                kIsWeb
                    ? Uri.parse('') // TODO
                    : Uri.parse(''), // TODO
          ),
        );
        authorizationCode = credential.authorizationCode;
        identityToken = credential.identityToken;
      }

      // This is the endpoint that will convert an authorization code obtained
      // via Sign in with Apple into a session in your system
      final http.Response response = await apiService.post(
        'auth/apple/',
        omitBearerToken: true,
        contentType: 'application/json',
        body: <String, dynamic>{
          'access_token': authorizationCode,
          'id_token': identityToken,
        },
      );

      final AuthResponse authResult = AuthResponse.fromJson(
        jsonDecode(response.body) as Map<String, dynamic>,
      );

      if (response.statusCode == 200) {
        try {
          /// Save the token
          apiService.authenticationToken = authResult.accessToken;
          await storageService.writeString('token', authResult.accessToken);

          return authResult;
        } catch (error) {
          await disconnectProviders();
          throw Exception('AuthService - error while parsing the user: $error');
        }
      } else {
        await disconnectProviders();
        return authResult;
      }
    } //handles the error if user cancels apple signin and stops app crashing
    on PlatformException catch (e) {
      if (e.code == 'cancelled') {
        // User canceled the sign in
        return AuthResponse(
          result: <String, dynamic>{},
          accessToken: '',
          message: 'Sign in cancelled',
          status: 0,
          success: false,
        );
      } else {
        // Other authorization error occurred
        throw Exception('Authorization error: $e');
      }
    } on SignInWithAppleAuthorizationException catch (e) {
      // Other error occurred
      return AuthResponse(
        result: <String, dynamic>{},
        accessToken: '',
        message: e.message,
        status: 0,
        success: false,
      );
    } catch (e) {
      // Other error occurred
      throw Exception('Authorization error: $e');
    }
  }

  late GoogleSignIn _googleSignIn;

  void init() {
    _googleSignIn = GoogleSignIn(
      scopes: <String>[
        'email',
      ],
    );
  }

  // Login with Google.
  Future<AuthResponse> googleSignIn() async {
    try {
      // Clear cache
      await _googleSignIn.currentUser?.clearAuthCache();

      // Try to login silently
      final GoogleSignInAccount? result =
          await _googleSignIn.signInSilently() ?? await _googleSignIn.signIn();

      if (result != null) {
        final GoogleSignInAuthentication googleKey =
            await result.authentication;

        // Login in backend
        final http.Response response = await apiService.post(
          'auth/google/',
          body: <String, dynamic>{
            'access_token': googleKey.accessToken,
            'id_token': googleKey.idToken,
          },
          omitBearerToken: true,
          contentType: 'application/json',
        );

        final AuthResponse authResult = AuthResponse.fromJson(
          jsonDecode(response.body) as Map<String, dynamic>,
        );

        if (response.statusCode == 200) {
          try {
            /// Save the token
            apiService.authenticationToken = authResult.accessToken;
            await storageService.writeString(
              'token',
              authResult.accessToken,
            );

            return authResult;
          } catch (error) {
            await disconnectProviders();
            throw Exception(
              'AuthService - error while parsing the user: $error',
            );
          }
        } else if (response.statusCode == 400) {
          await disconnectProviders();
          return authResult;
        } else {
          await disconnectProviders();
          throw Exception('AuthService - ${authResult.message}');
        }
      }
      return AuthResponse(
        result: <String, dynamic>{},
        accessToken: '',
        message:
            "Google auth isn't working at the moment. Please try again later.",
        status: 0,
        success: false,
      );
    } catch (e) {
      // Other error occurred
      throw Exception('Catched an error while logging in with Google: $e');
    }
  }

  @override
  Future<void> disconnectProviders() async {
    // Disconnect providers
    // Disconnect from Apple.

    // Disconnect from Google.
    try {
      await _googleSignIn.disconnect();
    } catch (e) {
      throw Exception(
        'AuthService - error while disconnecting from google: $e',
      );
    }
    super.disconnectProviders();
  }
}
